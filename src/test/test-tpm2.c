/* SPDX-License-Identifier: LGPL-2.1-or-later */
#include <tss2/tss2_mu.h>

#include "tpm2-util.h"
#include "tests.h"

static void test_tpm2_parse_pcrs_one(const char *s, uint32_t mask, int ret) {
        uint32_t m;

        assert_se(tpm2_parse_pcrs(s, &m) == ret);

        if (ret >= 0)
                assert_se(m == mask);
}

TEST(tpm2_parse_pcrs) {
        test_tpm2_parse_pcrs_one("", 0, 0);
        test_tpm2_parse_pcrs_one("0", 1, 0);
        test_tpm2_parse_pcrs_one("1", 2, 0);
        test_tpm2_parse_pcrs_one("0,1", 3, 0);
        test_tpm2_parse_pcrs_one("0+1", 3, 0);
        test_tpm2_parse_pcrs_one("0-1", 0, -EINVAL);
        test_tpm2_parse_pcrs_one("0,1,2", 7, 0);
        test_tpm2_parse_pcrs_one("0+1+2", 7, 0);
        test_tpm2_parse_pcrs_one("0+1,2", 7, 0);
        test_tpm2_parse_pcrs_one("0,1+2", 7, 0);
        test_tpm2_parse_pcrs_one("0,2", 5, 0);
        test_tpm2_parse_pcrs_one("0+2", 5, 0);
        test_tpm2_parse_pcrs_one("foo", 0, -EINVAL);
}

TEST(tpm2_util_pbkdf2_hmac_sha256) {

        /*
         * The test vectors from RFC 6070 [1] are for dkLen of 20 as it's SHA1
         * other RFCs I bumped into had various differing dkLen and iter counts,
         * so this was generated using Python's hmacmodule.
         *
         * 1. https://www.rfc-editor.org/rfc/rfc6070.html#page-2
         */
        static const struct {
                const uint8_t pass[256];
                size_t passlen;
                const uint8_t salt[256];
                size_t saltlen;
                uint8_t expected[SHA256_DIGEST_SIZE];
        } test_vectors[] = {
                { .pass={'f', 'o', 'o', 'p', 'a', 's', 's'},                                                                        .passlen=7,  .salt={'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '1', '2', '3', '4', '5'}, .saltlen=16, .expected={0xCB, 0xEA, 0x27, 0x23, 0x9A, 0x65, 0x99, 0xF6, 0x8C, 0x26, 0x54, 0x80, 0x5C, 0x63, 0x61, 0xD2, 0x91, 0x0A, 0x60, 0x3F, 0xC2, 0xF5, 0xF0, 0xAB, 0x55, 0x8B, 0x46, 0x07, 0x60, 0x93, 0xAB, 0xCB} },
                { .pass={'f', 'o', 'o', 'p', 'a', 's', 's'},                                                                        .passlen=7,  .salt={0x00, 'h', 'f', 's', 'd', 'j', 'h', 'f', 'd', 'j', 'h', 'j', 'd', 'f', 's'},     .saltlen=15, .expected={0x2B, 0xDF, 0x52, 0x29, 0x48, 0x3F, 0x98, 0x25, 0x01, 0x19, 0xB4, 0x42, 0xBC, 0xA7, 0x38, 0x5D, 0xCD, 0x08, 0xBD, 0xDC, 0x33, 0xBF, 0x32, 0x5E, 0x31, 0x87, 0x54, 0xFF, 0x2C, 0x23, 0x68, 0xFF} },
                { .pass={'f', 'o', 'o', 'p', 'a', 's', 's'},                                                                        .passlen=7,  .salt={'m', 'y', 's', 'a', 0x00, 'l', 't'},                                             .saltlen=7,  .expected={0x7C, 0x24, 0xB4, 0x4D, 0x30, 0x11, 0x53, 0x24, 0x87, 0x56, 0x24, 0x10, 0xBA, 0x9F, 0xF2, 0x4E, 0xBB, 0xF5, 0x03, 0x56, 0x2B, 0xB1, 0xA1, 0x92, 0x8B, 0x5F, 0x32, 0x02, 0x23, 0x1F, 0x79, 0xE6} },
                { .pass={'p', 'a', 's', 's', 'w', 'i', 't', 'h', 'n', 'u', 'l', 'l', 0x00, 'p', 'a', 's', 's', 'w', 'o', 'r', 'd'}, .passlen=21, .salt={'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '1', '2', '3', '4', '5'}, .saltlen=16, .expected={0xE9, 0x53, 0xB7, 0x1D, 0xAB, 0xD1, 0xC1, 0xF3, 0xC4, 0x7F, 0x18, 0x96, 0xDD, 0xD7, 0x6B, 0xC6, 0x6A, 0xBD, 0xFB, 0x12, 0x7C, 0xF8, 0x68, 0xDC, 0x6E, 0xEF, 0x29, 0xCC, 0x1B, 0x30, 0x5B, 0x74} },
                { .pass={'p', 'a', 's', 's', 'w', 'i', 't', 'h', 'n', 'u', 'l', 'l', 0x00, 'p', 'a', 's', 's', 'w', 'o', 'r', 'd'}, .passlen=21, .salt={0x00, 'h', 'f', 's', 'd', 'j', 'h', 'f', 'd', 'j', 'h', 'j', 'd', 'f', 's'},     .saltlen=15, .expected={0x51, 0xA3, 0x82, 0xA5, 0x2F, 0x48, 0x84, 0xB3, 0x02, 0x0D, 0xC2, 0x42, 0x9A, 0x8F, 0x86, 0xCC, 0x66, 0xFD, 0x65, 0x87, 0x89, 0x07, 0x2B, 0x07, 0x82, 0x42, 0xD6, 0x6D, 0x43, 0xB8, 0xFD, 0xCF} },
                { .pass={'p', 'a', 's', 's', 'w', 'i', 't', 'h', 'n', 'u', 'l', 'l', 0x00, 'p', 'a', 's', 's', 'w', 'o', 'r', 'd'}, .passlen=21, .salt={'m', 'y', 's', 'a', 0x00, 'l', 't'},                                             .saltlen=7,  .expected={0xEC, 0xFB, 0x5D, 0x5F, 0xF6, 0xA6, 0xE0, 0x79, 0x50, 0x64, 0x36, 0x64, 0xA3, 0x9A, 0x5C, 0xF3, 0x7A, 0x87, 0x0B, 0x64, 0x51, 0x59, 0x75, 0x64, 0x8B, 0x78, 0x2B, 0x62, 0x8F, 0x68, 0xD9, 0xCC} },
                { .pass={0x00, 'p', 'a', 's', 's'},                                                                                 .passlen=5,  .salt={'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '1', '2', '3', '4', '5'}, .saltlen=16, .expected={0x8A, 0x9A, 0x47, 0x9A, 0x91, 0x22, 0x2F, 0x56, 0x29, 0x4F, 0x26, 0x00, 0xE7, 0xB3, 0xEB, 0x63, 0x6D, 0x51, 0xF2, 0x60, 0x17, 0x08, 0x20, 0x70, 0x82, 0x8F, 0xA3, 0xD7, 0xBE, 0x2B, 0xD5, 0x5D} },
                { .pass={0x00, 'p', 'a', 's', 's'},                                                                                 .passlen=5,  .salt={0x00, 'h', 'f', 's', 'd', 'j', 'h', 'f', 'd', 'j', 'h', 'j', 'd', 'f', 's'},     .saltlen=15, .expected={0x72, 0x3A, 0xF5, 0xF7, 0xCD, 0x6C, 0x12, 0xDD, 0x53, 0x28, 0x46, 0x0C, 0x19, 0x0E, 0xF2, 0x91, 0xDE, 0xEA, 0xF9, 0x6F, 0x74, 0x32, 0x34, 0x3F, 0x84, 0xED, 0x8D, 0x2A, 0xDE, 0xC9, 0xC6, 0x34} },
                { .pass={0x00, 'p', 'a', 's', 's'},                                                                                 .passlen=5,  .salt={'m', 'y', 's', 'a', 0x00, 'l', 't'},                                             .saltlen=7,  .expected={0xE3, 0x07, 0x12, 0xBE, 0xEE, 0xF5, 0x5D, 0x18, 0x72, 0xF4, 0xCF, 0xF1, 0x20, 0x6B, 0xD6, 0x66, 0xCD, 0x7C, 0xE7, 0x4F, 0xC2, 0x16, 0x70, 0x5B, 0x9B, 0x2F, 0x7D, 0xE2, 0x3B, 0x42, 0x3A, 0x1B} },
        };

        uint8_t res[SHA256_DIGEST_SIZE];
        for(size_t i = 0; i < sizeof(test_vectors)/sizeof(test_vectors[0]); i++) {

                int rc = tpm2_util_pbkdf2_hmac_sha256(
                                test_vectors[i].pass,
                                test_vectors[i].passlen,
                                test_vectors[i].salt,
                                test_vectors[i].saltlen,
                                res);
                assert_se(rc == 0);
                assert_se(memcmp(test_vectors[i].expected, res, SHA256_DIGEST_SIZE) == 0);
        }
}

#if HAVE_TPM2

TEST(tpm2_util_persistent_to_esys_tr) {
        /* Generated by:
         * tpm2_createprimary -c primary.ctx
         * tpm2_evictcontrol -c primary.ctx 0x81000002
         * tpm2_readpublic -c 0x81000002 -t handle.tr -n name.bin -o public.bin
         * xxd -i handle.tr
         * xxd -i name.bin
         * xxd -i public.bin
         */
        static const unsigned char handle_tr[] = {
                0x81, 0x00, 0x00, 0x02, 0x00, 0x22, 0x00, 0x0b, 0x0a, 0xf1, 0xff, 0x58,
                0x1d, 0x88, 0xd1, 0x7b, 0x57, 0xa6, 0x1d, 0xbc, 0xb5, 0xe7, 0xe1, 0x5c,
                0xe9, 0xc7, 0xa8, 0x82, 0xed, 0x37, 0x7f, 0x34, 0x5a, 0x4e, 0x53, 0x0c,
                0x07, 0x80, 0x3b, 0x06, 0x00, 0x00, 0x00, 0x01, 0x01, 0x1a, 0x00, 0x01,
                0x00, 0x0b, 0x00, 0x03, 0x00, 0x72, 0x00, 0x00, 0x00, 0x06, 0x00, 0x80,
                0x00, 0x43, 0x00, 0x10, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
                0x86, 0x1a, 0xbc, 0xd5, 0x76, 0x61, 0x16, 0x2c, 0x91, 0x2e, 0x29, 0xd0,
                0xed, 0x42, 0xff, 0xcc, 0x4e, 0x7c, 0xaa, 0x3c, 0xca, 0xd4, 0x73, 0x3a,
                0x3e, 0xa3, 0x0d, 0x2a, 0x16, 0x44, 0xbe, 0x38, 0x08, 0xde, 0xd6, 0xd8,
                0xb1, 0xce, 0x20, 0xf9, 0x73, 0x67, 0x9d, 0x50, 0xb2, 0x97, 0xb0, 0x52,
                0xc8, 0x1c, 0x36, 0x2e, 0x15, 0x19, 0x5b, 0x7e, 0xcd, 0x9f, 0xd7, 0x91,
                0x74, 0xcf, 0x63, 0x73, 0x15, 0x71, 0xfe, 0xe4, 0x67, 0x77, 0xbb, 0x59,
                0xa6, 0xf2, 0xab, 0x40, 0x9b, 0xcc, 0xa4, 0xe5, 0xfc, 0x26, 0x60, 0xaf,
                0xe7, 0x9f, 0xf9, 0x55, 0xde, 0x1d, 0x10, 0x39, 0x98, 0x3b, 0x30, 0x22,
                0x94, 0xc3, 0xb1, 0xaa, 0xa2, 0xcc, 0x8d, 0x52, 0x2f, 0xc5, 0x15, 0x82,
                0x4a, 0xae, 0xc7, 0xe1, 0x6c, 0x4d, 0x11, 0xaf, 0x0e, 0x6b, 0xe5, 0xb4,
                0x71, 0x15, 0x97, 0x58, 0x84, 0x4b, 0xf0, 0x8a, 0x55, 0x4d, 0xdf, 0x56,
                0x62, 0xb5, 0xea, 0x24, 0xcf, 0x79, 0x92, 0xf6, 0x5d, 0x50, 0xbc, 0xeb,
                0xb7, 0xa0, 0xd4, 0xd0, 0xe4, 0x30, 0xf6, 0x52, 0x67, 0x74, 0xb5, 0xbc,
                0x3f, 0x60, 0xe5, 0x45, 0xdd, 0xf7, 0x43, 0x37, 0x4a, 0x51, 0xd3, 0x38,
                0xa3, 0xac, 0xfd, 0x14, 0x8a, 0x9a, 0x54, 0xee, 0xd7, 0x8e, 0x0c, 0x13,
                0x5f, 0x7a, 0x51, 0x7b, 0x71, 0xfe, 0xf1, 0x0e, 0x82, 0xdd, 0x05, 0x41,
                0x04, 0x30, 0xce, 0x7b, 0x84, 0x50, 0x76, 0x52, 0x7b, 0x19, 0xed, 0x9e,
                0x68, 0xc4, 0x8d, 0x4c, 0x16, 0xcc, 0xc3, 0x53, 0xc1, 0x54, 0x87, 0xf5,
                0x77, 0x33, 0x76, 0xab, 0x20, 0x7a, 0xe4, 0x16, 0xda, 0x7e, 0xc5, 0x64,
                0x52, 0x50, 0x0d, 0xd9, 0x7a, 0xd6, 0x04, 0x06, 0xc8, 0x50, 0xee, 0xb4,
                0x6f, 0xb8, 0xc7, 0xf5, 0xf2, 0x5b, 0x48, 0x6e, 0xba, 0x15, 0x1c, 0xfb,
                0x5b, 0xd8, 0x96, 0x49
        };

        static const unsigned char name_bin[] = {
                0x00, 0x22, /* size is not stored in binary file, manually add in 34 in big endian */
                0x00, 0x0b, 0x0a, 0xf1, 0xff, 0x58, 0x1d, 0x88, 0xd1, 0x7b, 0x57, 0xa6,
                0x1d, 0xbc, 0xb5, 0xe7, 0xe1, 0x5c, 0xe9, 0xc7, 0xa8, 0x82, 0xed, 0x37,
                0x7f, 0x34, 0x5a, 0x4e, 0x53, 0x0c, 0x07, 0x80, 0x3b, 0x06
        };

        static const unsigned char public_bin[] = {
                0x01, 0x1a, 0x00, 0x01, 0x00, 0x0b, 0x00, 0x03, 0x00, 0x72, 0x00, 0x00,
                0x00, 0x06, 0x00, 0x80, 0x00, 0x43, 0x00, 0x10, 0x08, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x01, 0x00, 0x86, 0x1a, 0xbc, 0xd5, 0x76, 0x61, 0x16, 0x2c,
                0x91, 0x2e, 0x29, 0xd0, 0xed, 0x42, 0xff, 0xcc, 0x4e, 0x7c, 0xaa, 0x3c,
                0xca, 0xd4, 0x73, 0x3a, 0x3e, 0xa3, 0x0d, 0x2a, 0x16, 0x44, 0xbe, 0x38,
                0x08, 0xde, 0xd6, 0xd8, 0xb1, 0xce, 0x20, 0xf9, 0x73, 0x67, 0x9d, 0x50,
                0xb2, 0x97, 0xb0, 0x52, 0xc8, 0x1c, 0x36, 0x2e, 0x15, 0x19, 0x5b, 0x7e,
                0xcd, 0x9f, 0xd7, 0x91, 0x74, 0xcf, 0x63, 0x73, 0x15, 0x71, 0xfe, 0xe4,
                0x67, 0x77, 0xbb, 0x59, 0xa6, 0xf2, 0xab, 0x40, 0x9b, 0xcc, 0xa4, 0xe5,
                0xfc, 0x26, 0x60, 0xaf, 0xe7, 0x9f, 0xf9, 0x55, 0xde, 0x1d, 0x10, 0x39,
                0x98, 0x3b, 0x30, 0x22, 0x94, 0xc3, 0xb1, 0xaa, 0xa2, 0xcc, 0x8d, 0x52,
                0x2f, 0xc5, 0x15, 0x82, 0x4a, 0xae, 0xc7, 0xe1, 0x6c, 0x4d, 0x11, 0xaf,
                0x0e, 0x6b, 0xe5, 0xb4, 0x71, 0x15, 0x97, 0x58, 0x84, 0x4b, 0xf0, 0x8a,
                0x55, 0x4d, 0xdf, 0x56, 0x62, 0xb5, 0xea, 0x24, 0xcf, 0x79, 0x92, 0xf6,
                0x5d, 0x50, 0xbc, 0xeb, 0xb7, 0xa0, 0xd4, 0xd0, 0xe4, 0x30, 0xf6, 0x52,
                0x67, 0x74, 0xb5, 0xbc, 0x3f, 0x60, 0xe5, 0x45, 0xdd, 0xf7, 0x43, 0x37,
                0x4a, 0x51, 0xd3, 0x38, 0xa3, 0xac, 0xfd, 0x14, 0x8a, 0x9a, 0x54, 0xee,
                0xd7, 0x8e, 0x0c, 0x13, 0x5f, 0x7a, 0x51, 0x7b, 0x71, 0xfe, 0xf1, 0x0e,
                0x82, 0xdd, 0x05, 0x41, 0x04, 0x30, 0xce, 0x7b, 0x84, 0x50, 0x76, 0x52,
                0x7b, 0x19, 0xed, 0x9e, 0x68, 0xc4, 0x8d, 0x4c, 0x16, 0xcc, 0xc3, 0x53,
                0xc1, 0x54, 0x87, 0xf5, 0x77, 0x33, 0x76, 0xab, 0x20, 0x7a, 0xe4, 0x16,
                0xda, 0x7e, 0xc5, 0x64, 0x52, 0x50, 0x0d, 0xd9, 0x7a, 0xd6, 0x04, 0x06,
                0xc8, 0x50, 0xee, 0xb4, 0x6f, 0xb8, 0xc7, 0xf5, 0xf2, 0x5b, 0x48, 0x6e,
                0xba, 0x15, 0x1c, 0xfb, 0x5b, 0xd8, 0x96, 0x49
        };

        int r = dlopen_tpm2();
        assert_se(r >= 0);

        TPM2B_PUBLIC pub = {};
        size_t offset = 0;
        TSS2_RC rc = Tss2_MU_TPM2B_PUBLIC_Unmarshal(
            public_bin,
            sizeof(public_bin),
            &offset,
            &pub);
        assert_se(rc == TSS2_RC_SUCCESS);


        TPM2B_NAME name = {};
        offset = 0;
        rc = Tss2_MU_TPM2B_NAME_Unmarshal(
            name_bin,
            sizeof(name_bin),
            &offset,
            &name);
        assert_se(rc == TSS2_RC_SUCCESS);


        uint8_t *check_buf = NULL;
        size_t check_buf_size = 0;
        r = tpm2_util_persistent_to_esys_tr(0x81000002, &pub, &name, &check_buf, &check_buf_size);
        assert_se(r == 0);
        assert_se(check_buf_size == sizeof(handle_tr));
        assert_se(memcmp(handle_tr, check_buf, check_buf_size) == 0);
}
#endif

DEFINE_TEST_MAIN(LOG_DEBUG);
